<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>CEAL: A Simple Example</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="contents">
<h1><a class="anchor" name="example_add">A Simple Example </a></h1>As a very simple example, consider a self-adjusting core program that simply adds the values of two modrefs, <code>m1</code> and <code>m2</code>, and stores the result in a output modref, <code>m3</code>. The meta program initially adds <code>1</code> and <code>2</code> (by having <code>m1</code> and <code>m2</code> contain 1 and 2, respectively), and then changes the input modref <code>m1</code> and uses change propagation to update the output (which is updated in <code>m3</code>). While this program is really too simple by itself to benefit from self-adjusting computation, it illustrates how simple meta and core programs are written using the CEAL primitives.<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;stdio.h&gt;</span>

afun <span class="keyword">add</span>(<a class="code" href="group__langcore.html#g2721ca82a2a5915adb3ed5f56c27f174" title="Modifiable references.">modref_t</a>* m_a,
              <a class="code" href="group__langcore.html#g2721ca82a2a5915adb3ed5f56c27f174" title="Modifiable references.">modref_t</a>* m_b,
              <a class="code" href="group__langcore.html#g2721ca82a2a5915adb3ed5f56c27f174" title="Modifiable references.">modref_t</a>* m_result)
{
  <span class="keywordtype">int</span> a = <a class="code" href="group__langcore.html#g162609872673b8b40cba41a4627ee6ee" title="Reads and returns the current value of a modifiable reference.">read</a>(m_a);
  <span class="keywordtype">int</span> b = <a class="code" href="group__langcore.html#g162609872673b8b40cba41a4627ee6ee" title="Reads and returns the current value of a modifiable reference.">read</a>(m_b);  
  <a class="code" href="group__langcore.html#gc5050d38e1da1e6aaf9ed2494429f5bf" title="Writes the given modifiable reference m with the given value val.">write</a>(m_result, (<span class="keywordtype">void</span>*) (a + b));
}

<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv) {

  <a class="code" href="group__langmeta.html#g2c297a0a9b5c1b23e4176b6fa99841db" title="An abstract type representing a self-adjusting core computation.">slime_t</a>* slime = <a class="code" href="group__langmeta.html#g36464d764ef411f14c68682a2fb577bc" title="Start a new computation.">slime_open</a>();
  
  <a class="code" href="group__langcore.html#g2721ca82a2a5915adb3ed5f56c27f174" title="Modifiable references.">modref_t</a>* m1 = <a class="code" href="group__langcore.html#g450cffd84b888c265a63ab679946be19" title="Creates a new, empty modifiable reference and returns a pointer to it.">modref</a>();
  <a class="code" href="group__langcore.html#g2721ca82a2a5915adb3ed5f56c27f174" title="Modifiable references.">modref_t</a>* m2 = <a class="code" href="group__langcore.html#g450cffd84b888c265a63ab679946be19" title="Creates a new, empty modifiable reference and returns a pointer to it.">modref</a>();
  <a class="code" href="group__langcore.html#g2721ca82a2a5915adb3ed5f56c27f174" title="Modifiable references.">modref_t</a>* m3 = <a class="code" href="group__langcore.html#g450cffd84b888c265a63ab679946be19" title="Creates a new, empty modifiable reference and returns a pointer to it.">modref</a>();
    
  <a class="code" href="group__langcore.html#gc5050d38e1da1e6aaf9ed2494429f5bf" title="Writes the given modifiable reference m with the given value val.">write</a>(m1, (<span class="keywordtype">void</span>*) 1);
  <a class="code" href="group__langcore.html#gc5050d38e1da1e6aaf9ed2494429f5bf" title="Writes the given modifiable reference m with the given value val.">write</a>(m2, (<span class="keywordtype">void</span>*) 2);  
    
  printf(<span class="stringliteral">"m1 holds %d, m2 holds %d\n"</span>,
         <a class="code" href="group__langmeta.html#g4d403ba6f5076f6fd51163e6bcec4fe5" title="Inspect the value of a modref. This is the meta-level analogue to read.">modref_deref</a>(m1),
         <a class="code" href="group__langmeta.html#g4d403ba6f5076f6fd51163e6bcec4fe5" title="Inspect the value of a modref. This is the meta-level analogue to read.">modref_deref</a>(m2));
  
  <span class="keyword">add</span>(m1, m2, m3);

  printf(<span class="stringliteral">"m3 holds %d\n\n"</span>,
         <a class="code" href="group__langmeta.html#g4d403ba6f5076f6fd51163e6bcec4fe5" title="Inspect the value of a modref. This is the meta-level analogue to read.">modref_deref</a>(m3));
  
  {
    <span class="keywordtype">int</span> i;

    <span class="keywordflow">for</span>(i = 2; i &lt; 10; i++) {
      <a class="code" href="group__langmeta.html#g9710332ac732c5d8f1814fd5f0afaf78" title="Set current time to computation&amp;#39;s start-time.">slime_meta_start</a>();
      
      <span class="comment">/* Change some input: */</span>
      <a class="code" href="group__langcore.html#gc5050d38e1da1e6aaf9ed2494429f5bf" title="Writes the given modifiable reference m with the given value val.">write</a>(m1, (<span class="keywordtype">void</span>*) i);
      printf(<span class="stringliteral">"now m1 gets %d\n"</span>, i);

      <span class="comment">/* Change-propagate: */</span>
      printf(<span class="stringliteral">"propagating ... \n"</span>);
      <a class="code" href="group__langmeta.html#g266c38f39f8be698b6a37ede35325083" title="Propagate the current computation.">slime_propagate</a>();
      printf(<span class="stringliteral">"propagating done.\n"</span>);

      <span class="comment">/* Look at updated output: */</span>
      printf(<span class="stringliteral">"now m3 holds %d\n\n"</span>,
             <a class="code" href="group__langmeta.html#g4d403ba6f5076f6fd51163e6bcec4fe5" title="Inspect the value of a modref. This is the meta-level analogue to read.">modref_deref</a>(m3));
    }
  }
  
  <a class="code" href="group__langmeta.html#g491438729ee8dbabbd34e1b95ce78785" title="Close the given computation.">slime_close</a>(slime);
  
  <span class="keywordflow">return</span> 0;
}
</pre></div><p>
The code works as follows:<p>
<ul>
<li>
The core program consists of a single function, <code>add</code>. The meta program is contained in <code>main</code>.<p>
</li>
<li>
The return-type of core functions is <code>afun</code>. This is a special synonym for <code>void</code>, meaning that core functions have no return value. Instead, their results must be handled in so-called <em>destination-passing style</em> (DPS), where <em>destinations</em> are modrefs. In the example, <code>m3</code> is the destination for the result of the addition.<p>
</li>
<li>
The meta program begins setting up the core computation by using <a class="el" href="group__langmeta.html#g36464d764ef411f14c68682a2fb577bc">slime_open</a> to get a pointer to an abstract value of type <a class="el" href="group__langmeta.html#g2c297a0a9b5c1b23e4176b6fa99841db">slime_t</a>. This value will represent the core computation and its state.<p>
</li>
<li>
Next, the meta program creates and writes input modrefs <code>m1</code> and <code>m2</code>, and creates a destination for the result, <code>m3</code>. The destination <code>m3</code> will be written with the output of the core program.<p>
</li>
<li>
The meta program performs the initial-run of the core program by simply calling <code>add</code> with the modrefs <code>m1</code>, <code>m2</code> and <code>m3</code>.<p>
</li>
<li>
Then the meta program loops: <ul>
<li>
It writes <code>m1</code> with a new input value. </li>
<li>
It uses <a class="el" href="group__langmeta.html#g266c38f39f8be698b6a37ede35325083">slime_propagate</a> to automatically update the output in <code>m3</code>. </li>
<li>
It prints this new output value. </li>
</ul>
<p>
Before changing the value of <code>m1</code>, however, the meta program uses <a class="el" href="group__langmeta.html#g9710332ac732c5d8f1814fd5f0afaf78">slime_meta_start</a> to ensure that this change is recorded as an <em>input change</em> that happens <em>before</em> the core computation (as represented in the execution trace). If this step is omitted, the changes to <code>m1</code> will behave like writes that happen <em>after</em> the core program has finished using <code>m1</code>, and change propagation will perform no work. </li>
</ul>
<p>
We can compile and run this program as follows. Assuming <code>cealc</code> is in your <code>$PATH</code>, and that this program is stored in <code>testadd.c</code>, do the following:<p>
<div class="fragment"><pre class="fragment">  cealc testadd.c -o testadd
  ./testadd
</pre></div><p>
The program will then run and print something like:<p>
<div class="fragment"><pre class="fragment">m1 holds 1, m2 holds 2
m3 holds 3

now m1 gets 2
propagating ... 
propagating done.
now m3 holds 4

now m1 gets 3
propagating ... 
propagating done.
now m3 holds 5

now m1 gets 4
propagating ... 
propagating done.
now m3 holds 6

now m1 gets 5
propagating ... 
propagating done.
now m3 holds 7

now m1 gets 6
propagating ... 
propagating done.
now m3 holds 8

now m1 gets 7
propagating ... 
propagating done.
now m3 holds 9

now m1 gets 8
propagating ... 
propagating done.
now m3 holds 10

now m1 gets 9
propagating ... 
propagating done.
now m3 holds 11

</pre></div><p>
The next example explores a natural generalization of this core program: <a class="el" href="example_exptrees.html">A Less Simple Example</a> </div>
<hr size="1"><address style="text-align: right;"><small>Generated on Wed Mar 4 10:13:08 2009 for CEAL by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
