<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>CEAL Manual and User Guide (DRAFT)</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
<style type="text/css">
BODY, TD{
!  max-width: 5.5in;  
!  margin-left: 1in;
}
</style>
</head>
<!-- Generated by Doxygen 1.5.6 -->
<div class="contents">
<h1><a class="anchor" name="ex_arith_tree">Example: Arithmetic Trees </a></h1>The previous section (<a class="el" href="ex_add.html">Example: Add</a>) described a very simple core program that adds two numbers. Now we generalize this program to the case where each core input is a binary tree such that each leaf node contains an integer, and each internal node contains a binary operation (e.g., addition and multiplication) as well as links to its left and right subtrees.<p>
Abstractly, we might evaluate such a tree as a core program with the following psuedocode:<p>
<div class="fragment"><pre class="fragment">
  tree_eval(t):
    if t is a leaf:
      let a = integer at node
      return a      
    otherwise, t is an internal node:
      let binop = binary operation at the node
      let a = tree_eval(left(t))
      let b = tree_eval(right(t))
      return binop(a,b)              </pre></div><p>
To realize this psuedocode, let's start by making the tree's representation concrete:<p>
 <div class="fragment"><pre class="fragment"><span class="keyword">typedef</span> <span class="keyword">enum</span> {ADD, MUL} binop_t;
<span class="keyword">typedef</span> <span class="keyword">struct </span>tree_node_s {
  <span class="keyword">enum</span> {NUM, BINOP} kind;
  <span class="keyword">union </span>{
    <a class="code" href="group__langcore.html#g2721ca82a2a5915adb3ed5f56c27f174" title="Modifiable references.">modref_t</a>* num;
    <span class="keyword">struct </span>{ 
      binop_t binop;
      <a class="code" href="group__langcore.html#g2721ca82a2a5915adb3ed5f56c27f174" title="Modifiable references.">modref_t</a>* left;
      <a class="code" href="group__langcore.html#g2721ca82a2a5915adb3ed5f56c27f174" title="Modifiable references.">modref_t</a>* right;
    } binop;
  } u;
} tree_node_t;
</pre></div><p>
The nodes of the tree are represented by the type <code>tree_node_t</code>. Each tree node contains a <code>kind</code> which is either <code>NUM</code> or <code>BINOP</code>. If the kind is <code>NUM</code>, the node holds a number in a modref. If the kind is <code>BINOP</code>, the node contains the type of operation, <code>binop</code> (of type <code>binop_t</code>), and two modrefs, <code>left</code> and <code>right</code>, which contain pointers to the node's subtrees.<p>
Given this concrete representation, we can write a core program to evaluate a given tree as follows:<p>
 <div class="fragment"><pre class="fragment">afun tree_eval(tree_node_t* node, <a class="code" href="group__langcore.html#g2721ca82a2a5915adb3ed5f56c27f174" title="Modifiable references.">modref_t</a>* result) {
  <span class="keywordflow">if</span>(node-&gt;kind == NUM) {
    write_num(result, read_num(node-&gt;u.num));
  }
  <span class="keywordflow">else</span> <span class="keywordflow">if</span>(node-&gt;kind == BINOP) {
    <a class="code" href="group__langcore.html#g2721ca82a2a5915adb3ed5f56c27f174" title="Modifiable references.">modref_t</a> *result_left = <a class="code" href="group__langcore.html#g450cffd84b888c265a63ab679946be19" title="Creates a new, empty modifiable reference and returns a pointer to it.">modref</a>();
    tree_eval(<a class="code" href="group__langcore.html#g162609872673b8b40cba41a4627ee6ee" title="Reads and returns the current value of a modifiable reference.">read</a>(node-&gt;u.binop.left), result_left);

    <a class="code" href="group__langcore.html#g2721ca82a2a5915adb3ed5f56c27f174" title="Modifiable references.">modref_t</a> *result_right = <a class="code" href="group__langcore.html#g450cffd84b888c265a63ab679946be19" title="Creates a new, empty modifiable reference and returns a pointer to it.">modref</a>();
    tree_eval(<a class="code" href="group__langcore.html#g162609872673b8b40cba41a4627ee6ee" title="Reads and returns the current value of a modifiable reference.">read</a>(node-&gt;u.binop.right), result_right);

    <span class="keywordflow">if</span>(node-&gt;u.binop.binop == ADD) {
      write_num(result, read_num(result_left) + read_num(result_right));
    }
    <span class="keywordflow">else</span> <span class="keywordflow">if</span>(node-&gt;u.binop.binop == MUL) {
      write_num(result, read_num(result_left) * read_num(result_right));
    }
    <span class="keywordflow">else</span> {
      abort();
    }
  }
  <span class="keywordflow">else</span> {
    abort();
  }
}
</pre></div><p>
This code realizes the psuedocode we wrote earlier. It uses two simple macros, <code>read_num</code> and <code>write_num</code>, which hide the casting between <code>void*</code> and <code>int</code> for <code>read</code> and <code>write</code> operations, respectively:<p>
 <div class="fragment"><pre class="fragment"><span class="preprocessor">#define read_num(m)        ((int) read(m))</span>
<span class="preprocessor">#define write_num(m, num)  write(m, (void*)(num))</span>
</pre></div><p>
<a class="el" href="ex_arith_tree_full.html">Example: Arithmetic Trees: Full Code</a> contains the full code for this example, including a meta program that changes each leaf node and runs change propagation. </div>
<hr size="1"><address style="text-align: right;"><small>Generated on Thu Mar 5 14:27:55 2009 for CEAL by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
