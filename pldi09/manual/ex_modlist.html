<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>CEAL Manual and User Guide (DRAFT)</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
<style type="text/css">
BODY, TD{
!  max-width: 5.5in;  
!  margin-left: 1in;
}
</style>
</head>
<!-- Generated by Doxygen 1.5.6 -->
<div class="contents">
<h1><a class="anchor" name="ex_modlist">Example: Modifiable Lists </a></h1>So-called <b>modifiable lists</b> (<em>modlists</em>, for short) are analygous to ordinary linked lists except that in a modifiable list, each cell stores the next cell (i.e., it's "tail") in a modifiable reference rather than in a ordinary pointer field. Concretely, the cells of a modifiable list are instances of the following <code>struct:</code> <p>
 <div class="fragment"><pre class="fragment"><span class="keyword">typedef</span> <span class="keyword">struct </span>cons_cell_s {
  <span class="keywordtype">void</span>* hd;      <span class="comment">/* "head" */</span>
  <a class="code" href="group__langcore.html#g2721ca82a2a5915adb3ed5f56c27f174" title="Modifiable references.">modref_t</a>* tl;  <span class="comment">/* "tail" */</span>
} cons_cell_t;
</pre></div><p>
When a meta program uses a modlist as an input to some core program, the modifiable references in the list allow the meta program to insert and delete list elements and propagate these changes through the core program (as usual, using <a class="el" href="group__langmeta.html#g266c38f39f8be698b6a37ede35325083">slime_propagate</a>).<h2><a class="anchor" name="ex_modlist_alloc">
Allocating and Initializing List Cells</a></h2>
To initialize a new list cell, we'll use an <em>initialization function</em> like this:<p>
 <div class="fragment"><pre class="fragment">ifun cons_cell_init(cons_cell_t* cell, <span class="keywordtype">void</span>* hd) {
  cell-&gt;hd = hd;
  cell-&gt;tl = <a class="code" href="group__langcore.html#g450cffd84b888c265a63ab679946be19" title="Creates a new, empty modifiable reference and returns a pointer to it.">modref</a>();
}
</pre></div><p>
This function initializes memory for a list cell with a given element (<code>hd</code>). It also creates an empty modref to hold the tail of the list. We use the return type <code>ifun</code> for all initialization functions, which is a special synonym for <code>void</code>.<p>
Given this initialization function, we'll allocate new cons cells using the <a class="el" href="group__langcore.html#g0f2f4b7eb5734fff689ce8c3cbd313da">alloc</a> primitive:<p>
 <div class="fragment"><pre class="fragment">cons_cell_t* Cons(<span class="keywordtype">void</span>* hd) {
  <span class="keywordflow">return</span> <a class="code" href="group__langcore.html#g0f2f4b7eb5734fff689ce8c3cbd313da" title="Allocate and initialize memory blocks.">alloc</a>(<span class="keyword">sizeof</span>(cons_cell_t), cons_cell_init, hd);
}
</pre></div><p>
The <a class="el" href="group__langcore.html#g0f2f4b7eb5734fff689ce8c3cbd313da">alloc</a> primitive takes: a <em>size</em>, the number of bytes to allocate; an initialization function to initialize the allocated memory; and zero or more <em>initialization arguments</em>, which are in turn passed to the initialization function. In the use above there is one initialization argument: the element to place in the "head" of the cons cell.<h2><a class="anchor" name="ex_modlist_creating">
Creating a List</a></h2>
Now that we can allocate new cons cells, we can write a simple function that stores the elements of an array in a modlist:<p>
 <div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> modlist_from_array(<span class="keywordtype">void</span>** eltv, <span class="keywordtype">int</span> eltc, <a class="code" href="group__langcore.html#g2721ca82a2a5915adb3ed5f56c27f174" title="Modifiable references.">modref_t</a>* list) {
  <a class="code" href="group__langcore.html#g2721ca82a2a5915adb3ed5f56c27f174" title="Modifiable references.">modref_t</a>* tl = list;
  <span class="keywordtype">int</span> i;
  <span class="keywordflow">for</span>(i = 0; i &lt; eltc; i++) {
    cons_cell_t* cell = Cons(eltv[i]);
    <a class="code" href="group__langcore.html#gc5050d38e1da1e6aaf9ed2494429f5bf" title="Writes the given modifiable reference m with the given value val.">write</a>(tl, cell);
    tl = cell-&gt;tl;
  }
  <a class="code" href="group__langcore.html#gc5050d38e1da1e6aaf9ed2494429f5bf" title="Writes the given modifiable reference m with the given value val.">write</a>(tl, NULL);
}  
</pre></div><p>
Note this this is a meta function, not a core function. In particular, the accesses of the array are not tracked, and future changes to the array will not affect the list. Functions like this are typically used by the meta program to build an input for a from-scratch run. After this run, the meta program can change the list (by inserting or removing some elements), and propagate these changes through any core program that uses the list as an input.<h2><a class="anchor" name="ex_modlist_map">
Mapping a List</a></h2>
Now consider the following core function: it takes a modlist as an input and produces a new modlist as an output where the input list elements <img class="formulaInl" alt="$x_1, x_2, \ldots, x_n$" src="form_6.png"> are mapped to corresponding output elements <img class="formulaInl" alt="$f(x_1), f(x_2),\ldots, f(x_n)$" src="form_7.png"> by a given mapping function <img class="formulaInl" alt="$f$" src="form_3.png">. We can write this simple function both <em>iteratively</em> and via <em>tail-recursion</em>.<h3><a class="anchor" name="ex_modlist_map_iter">
Iteratively</a></h3>
The iterative style, common to conventional C programming, uses a <code>while</code> loop to iterate through the cells in the input list and generate the corresponding cells of the output list:<p>
 <div class="fragment"><pre class="fragment">afun modlist_map_iter(cons_cell_t* cell_in,
                      <span class="keywordtype">void</span>* (*f)(<span class="keywordtype">void</span>* elt),
                      <a class="code" href="group__langcore.html#g2721ca82a2a5915adb3ed5f56c27f174" title="Modifiable references.">modref_t</a>* dest)
{
  <span class="keywordflow">while</span>(cell_in != NULL) {
    cons_cell_t* cell_out = Cons(f(cell_in-&gt;hd));
    <a class="code" href="group__langcore.html#gc5050d38e1da1e6aaf9ed2494429f5bf" title="Writes the given modifiable reference m with the given value val.">write</a>(dest, cell_out);
    dest = cell_out-&gt;tl;
    cell_in = <a class="code" href="group__langcore.html#g162609872673b8b40cba41a4627ee6ee" title="Reads and returns the current value of a modifiable reference.">read</a>(cell_in-&gt;tl);
  }
  <a class="code" href="group__langcore.html#gc5050d38e1da1e6aaf9ed2494429f5bf" title="Writes the given modifiable reference m with the given value val.">write</a>(dest, NULL);
}
</pre></div><h3><a class="anchor" name="ex_modlist_map_rec">
via Tail-Recursion</a></h3>
The tail-recursive style, common to functional programming, uses a recursive call to process the "tail" of the input list and build the corresponding "tail" of the output list. Recall that core functions must be written in destination-passing style (DPS); i.e., they communicate results through modref <em>destinations</em> that are passed as arguments, rather than by returning results directly as return values.<p>
 <div class="fragment"><pre class="fragment">afun modlist_map_rec(cons_cell_t* cell_in,
                     <span class="keywordtype">void</span>* (*f)(<span class="keywordtype">void</span>* elt),
                     <a class="code" href="group__langcore.html#g2721ca82a2a5915adb3ed5f56c27f174" title="Modifiable references.">modref_t</a>* dest)
{
  <span class="keywordflow">if</span>(cell_in == NULL)
    <a class="code" href="group__langcore.html#gc5050d38e1da1e6aaf9ed2494429f5bf" title="Writes the given modifiable reference m with the given value val.">write</a>(dest, NULL);
  <span class="keywordflow">else</span> {
    cons_cell_t* cell_out = Cons(f(cell_in-&gt;hd));
    <a class="code" href="group__langcore.html#gc5050d38e1da1e6aaf9ed2494429f5bf" title="Writes the given modifiable reference m with the given value val.">write</a>(dest, cell_out);
    modlist_map_rec(<a class="code" href="group__langcore.html#g162609872673b8b40cba41a4627ee6ee" title="Reads and returns the current value of a modifiable reference.">read</a>(cell_in-&gt;tl), f, cell_out-&gt;tl);
  }
}
</pre></div><p>
<code>cealc</code> attempts to realize a recursive call with an intra-procedural jump (i.e., a "goto") whenever it appears in a so-called "tail-position", as it does in this example. As a result of this, the iterative and tail-recursive solutions we've shown here exhibit the same performance characteristics (e.g., both use a bounded amount of stack space, regardless of the length of the input list).<h2><a class="anchor" name="ex_modlist_splitmerge">
Splitting and Merging Lists</a></h2>
List-sorting algorithms like quicksort and mergesort are often implemented with simple list primitives that:<p>
<ul>
<li>Split an input list (using some unary predicate) into two sublists.</li><li>Merge two input lists into a single output list (using some binary predicate).</li></ul>
<p>
For example, quicksort works by choosing a pivot element and splitting the remaining elements into two lists that contain, repsectively, the elements that are less than the pivot and the elements that are greater than the pivot. Recursively it sorts each of the two sublists, and then appends them, along with the pivot element, to create a sorted output list.<p>
Mergesort works by splitting the input list into two sublists (of roughly equal-length), recursively sorts each sublist, and then merges these sorted lists.<p>
We now consider the concrete implementations of these operations. We use the tail-recusion in these examples, but each can alternatively be rewritten in an iterative style, just as we did in <code>modlist_map_iter</code>.<h3><a class="anchor" name="ex_modlist_split">
Splitting a List in Two</a></h3>
Given a predicate <code>f</code> and an input list, we split the input list into two sublists. The first sublist contains all the elements for which the predicate is true, and the second sublist contains the elements for which it is false. The elements in each output list are ordered by their relative order in the input list.<p>
 <div class="fragment"><pre class="fragment">afun modlist_split(cons_cell_t* cell_in,
                   <span class="keywordtype">int</span> (*f)(<span class="keywordtype">void</span>* elt),
                   <a class="code" href="group__langcore.html#g2721ca82a2a5915adb3ed5f56c27f174" title="Modifiable references.">modref_t</a>* dest_1,
                   <a class="code" href="group__langcore.html#g2721ca82a2a5915adb3ed5f56c27f174" title="Modifiable references.">modref_t</a>* dest_2)
{
  <span class="keywordflow">if</span>(cell_in == NULL) {
    <a class="code" href="group__langcore.html#gc5050d38e1da1e6aaf9ed2494429f5bf" title="Writes the given modifiable reference m with the given value val.">write</a>(dest_1, NULL);
    <a class="code" href="group__langcore.html#gc5050d38e1da1e6aaf9ed2494429f5bf" title="Writes the given modifiable reference m with the given value val.">write</a>(dest_2, NULL);
  }
  <span class="keywordflow">else</span> {
    cons_cell_t* cell_out = Cons(cell_in-&gt;hd);
    <span class="keywordflow">if</span>(f(cell_in-&gt;hd)) {
      <a class="code" href="group__langcore.html#gc5050d38e1da1e6aaf9ed2494429f5bf" title="Writes the given modifiable reference m with the given value val.">write</a>(dest_1, cell_out);
      modlist_split(<a class="code" href="group__langcore.html#g162609872673b8b40cba41a4627ee6ee" title="Reads and returns the current value of a modifiable reference.">read</a>(cell_in-&gt;tl), f, cell_out-&gt;tl, dest_2);
    }
    <span class="keywordflow">else</span> {
      <a class="code" href="group__langcore.html#gc5050d38e1da1e6aaf9ed2494429f5bf" title="Writes the given modifiable reference m with the given value val.">write</a>(dest_2, cell_out);
      modlist_split(<a class="code" href="group__langcore.html#g162609872673b8b40cba41a4627ee6ee" title="Reads and returns the current value of a modifiable reference.">read</a>(cell_in-&gt;tl), f, dest_1, cell_out-&gt;tl);
    }
  }
}
</pre></div><h3><a class="anchor" name="ex_modlist_merge">
Merging Two Lists into One</a></h3>
Given a binary predicate <code>f</code> and two input lists, we merge the lists recursively by considering the first element of each list, call them <code>a</code> and <code>b</code>, and applying the predicate <code>f(a,b)</code>: if true, <code>a</code> is added to the output list; if false, <code>b</code> is added. This process continues until at least one input list is empty, in which case all the remaining elements of the other input list are added to the output list.<p>
Consider the use of this list primitive in a mergesort implementation. If the two input lists are each sorted (e.g., by recursively using mergesort) and the binary predicate reflects the ordering of the sorted elements, then the output list will contain all the input elements (from both lists) in a sorted order.<p>
 <div class="fragment"><pre class="fragment">afun modlist_merge(cons_cell_t* cell_in_1,
                   cons_cell_t* cell_in_2,
                   <span class="keywordtype">int</span> (*f)(<span class="keywordtype">void</span>* elt_a, <span class="keywordtype">void</span>* elt_b),
                   <a class="code" href="group__langcore.html#g2721ca82a2a5915adb3ed5f56c27f174" title="Modifiable references.">modref_t</a>* dest)
{
  <span class="keywordflow">if</span>(cell_in_1 == NULL) {
    <a class="code" href="group__langcore.html#gc5050d38e1da1e6aaf9ed2494429f5bf" title="Writes the given modifiable reference m with the given value val.">write</a>(dest, cell_in_2);
  }
  <span class="keywordflow">else</span> <span class="keywordflow">if</span>(cell_in_2 == NULL) {
    <a class="code" href="group__langcore.html#gc5050d38e1da1e6aaf9ed2494429f5bf" title="Writes the given modifiable reference m with the given value val.">write</a>(dest, cell_in_2);    
  }
  <span class="keywordflow">else</span> {
    <span class="keywordflow">if</span>(f(cell_in_1-&gt;hd, cell_in_2-&gt;hd)) {
      cons_cell_t* cell_out = Cons(cell_in_1-&gt;hd);
      <a class="code" href="group__langcore.html#gc5050d38e1da1e6aaf9ed2494429f5bf" title="Writes the given modifiable reference m with the given value val.">write</a>(dest, cell_out);
      modlist_merge(<a class="code" href="group__langcore.html#g162609872673b8b40cba41a4627ee6ee" title="Reads and returns the current value of a modifiable reference.">read</a>(cell_in_1-&gt;tl), cell_in_2, f, cell_out-&gt;tl);
    }
    <span class="keywordflow">else</span> {
      cons_cell_t* cell_out = Cons(cell_in_2-&gt;hd);
      <a class="code" href="group__langcore.html#gc5050d38e1da1e6aaf9ed2494429f5bf" title="Writes the given modifiable reference m with the given value val.">write</a>(dest, cell_out);
      modlist_merge(cell_in_1, <a class="code" href="group__langcore.html#g162609872673b8b40cba41a4627ee6ee" title="Reads and returns the current value of a modifiable reference.">read</a>(cell_in_2-&gt;tl), f, cell_out-&gt;tl);
    }
  }
}
</pre></div> </div>
<hr size="1"><address style="text-align: right;"><small>Generated on Thu Mar 5 14:27:55 2009 for CEAL by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
