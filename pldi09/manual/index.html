<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>CEAL Manual and User Guide (DRAFT)</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
<style type="text/css">
BODY, TD{
!  max-width: 5.5in;  
!  margin-left: 1in;
}
</style>
</head>
<!-- Generated by Doxygen 1.5.6 -->
<div class="contents">
<h1><a class="anchor" name="index">CEAL Manual and User Guide (DRAFT) </a></h1><h2><a class="anchor" name="abstract">
Abstract</a></h2>
CEAL is a C-based language for self-adjusting computation. CEAL extends C with a small set of primitives that allow programmers to write self-adjusting computations in a manner similar to conventional C programming and embed these computations into larger C programs.<p>
The current implementation of CEAL consists of a compiler, <code>cealc</code>, as well as a suite of CEAL benchmarks that we use for performance evaluation. This manual briefly describes how to download and build the <code>cealc</code> compiler. We also briefly describe how to use the CEAL language itself using examples from our benchmark suite.<p>
Your questions and comments are appreciated and should be directed to <a href="mailto:hammer@mpi-sws.org">hammer@mpi-sws.org</a>.<h2><a class="anchor" name="install">
Building from Source</a></h2>
Our build system is still a work in progress, but you should be able to compile and use the system in a local directory on your machine (there is no mechanism yet to install the tools permanently). The build process has the following requirements:<p>
<ul>
<li>Objective Caml: <a href="http://caml.inria.fr/ocaml/.">http://caml.inria.fr/ocaml/.</a></li><li>The GNU toolchain: <code>sh</code>, <code>make</code>, <code>gcc</code>, etc.</li><li>Perl 5 (or later)</li></ul>
<p>
Once you've got the prerequisites installed, download the source distribution:<p>
<a href="http://mpi-sws.org/~hammer/pldi09/ceal-0.1.1.tar.gz">http://mpi-sws.org/~hammer/pldi09/ceal-0.1.1.tar.gz</a><p>
Extract the source distribution to a local directory and change to this directory.<p>
To start building the system, begin by building CIL as follows:<p>
<div class="fragment"><pre class="fragment">
  cd cil
  ./configure
  make
  cd ..</pre></div><p>
Next, build the CEAL runtime library and the benchmark suite as follows:<p>
<div class="fragment"><pre class="fragment">
  make     </pre></div><p>
Now the <code>bin</code> directory should contain:<ul>
<li><code>cealc</code>, a script that invokes the CEAL compiler</li><li><code>libceal.a</code>, the runtime library,</li><li>a number of test programs, each compiled via <code>cealc</code>. Each testing program is named <code>test-appname</code> where <code>appname</code> is the name of a benchmark application.</li></ul>
<p>
Optionally, you can also re-generate this manual (if you have <code>doxygen</code> installed on your machine), as follows:<p>
<div class="fragment"><pre class="fragment">
  cd doc
  doxygen
  cd ..    </pre></div><p>
Then <code>doc/html/</code> will contain this manual in HTML format.<h2><a class="anchor" name="cealc">
The CEAL compiler</a></h2>
<code>cealc</code> is a perl-script wrapper for <code>cilly</code>, and <code>cilly</code> is itself a perl-script wrapper for CIL and <code>gcc</code>. Check out <a href="http://cil.sourceforge.net/">http://cil.sourceforge.net/</a> for information about both CIL and <code>cilly</code>. The purpose of this script is to invoke <code>cilly</code> with the right options to translate CEAL source code into C target code (and by default) compile it to a native binary via <code>gcc</code>. Its use is analogous to <code>cilly</code>, whose use is itself analogous to <code>gcc:</code> supply one or more source files as arguments and it will compile a binary <code>a.out</code>.<p>
Many <code>gcc</code> options work here too. The <code>-o</code> option can be used to redirect the output. The <code>-c</code> option can be used to create an object file only. As a general rule, any flag accepted by either <code>gcc</code> or <code>cilly</code> can be passed to this process and it will pass it along down the line as necessary. This fact is largely the result of the fact that <code>cilly</code> accepts options recognized by <code>gcc</code> and "does the right thing with them".<p>
Special Options:<p>
<ul>
<li><code>-nolibceal</code> Instead of the default behavior--linking against libceal--this option will attempt to compile (and/or link) without using libceal. This option is used when compiling libceal itself via <code>cealc</code>.</li>
</ul>
<h2><a class="anchor" name="prelim">
Preliminaries and Terminology</a></h2>
In this section we review the key notions involved in self-adjusting computation. Conceptually, a self-adjusting computation is made up of two stratified levels called <b>meta</b> and <b>core</b>, respectively. The core-level portion of the program (hereafter, the <em>core-program</em>) consists of the code that we expect to respond automatically to changes in its data (e.g., its input). The meta-level portion of the program (hereafter, the <em>meta-program</em>) is able to run one (or more) core programs, change their inputs, and automatically update the core outputs via a general purpose <b>change-propagation</b> mechanism. Although using the terms "core-program" and "meta-program" gives the impression that these levels run as separate executables, in fact both portions of the code are compiled and run together as a single executable; we use the term "program" loosely here to refer to a portion of code with a well-defined entry-point (e.g., a function and all the functions it calls)---not a separate binary executable.<p>
At a high-level, a typical meta-program is structured as follows. First it performs an <em>initial-run</em> of a core program:<p>
<div class="fragment"><pre class="fragment">
  1. construct initial core input
  2. run core program
  3. inspect core output  </pre></div><p>
In the initial run (also referred to as the <em>from-scratch</em> run), the self-adjusting framework transparently creates an <em>execution</em> <em>trace</em>. The trace describes the dynamic data and control dependencies of the core program's run, and records how the core program produced its output (and intermediate results, etc.) from its input.<p>
After the initial run, the meta program makes one or more changes to the core input. To get the output associated with the changed input in a conventional programming paradigm, the meta program would re-invoke the core program from-scratch to recompute the new output. However, in the self-adjusting setting the meta program uses <em>change-propagation</em> to automatically update the core output with respect to the input changes. Behind the scenes, change propagation uses the core program's execution trace to selectively re-execute the executions steps that are affected by the changes.<p>
<div class="fragment"><pre class="fragment">
  4. repeat:
      4.A change core input
      4.B propagate changes
      4.C inspect updated core output </pre></div><p>
The meta-program benefits from a self-adjusting core program when it is faster to use change propagation to update the output than to to recompute it from-scratch. There is a sizeable class of programs for which this performance benefit is asymptotic (e.g., for small changes, change propagation can sometimes be faster by a linear factor over recomputing from scratch). Although it may also be slower in some cases, it is only ever slower by a constant factor (again, when compared to running from scratch).<p>
We often say that a core program is <b>stable</b> for a certain class of input changes if we can show that for any such change, change propagation will always update the core output in a desirable amount of time. The property of a core program being stable is usually relative to which kinds of input changes we want to consider, and possibly the size of the input itself. As an example, consider a core program that produces a sequence of sorted elements given an unsorted input sequence. We might consider an input change to be an insertion or deletion of an input element. Then we might say the core program is stable if change propagation can respond to such a change in time O(log <em>n</em>), where <em>n</em> is the total number of input elements. In this case, the time for handling a small change via change propagation is consistent with the optimum time for maintaining a sorted list of elements under insertions and deletions.<p>
The stability of a core program is determined in part by how it's written, and core programs that do not exhibit good stability can sometimes be rewritten as stable ones.<h2><a class="anchor" name="prims">
Language Primitives</a></h2>
A central concept of self-adjusting computation is that of a modifiable reference. A <b>modifiable</b> <b>reference</b> (<em>modref</em> for short) is a mutable storage location that holds one word of mutable data (e.g., a pointer, an integer, etc.). Modrefs have type <a class="el" href="group__langcore.html#g2721ca82a2a5915adb3ed5f56c27f174">modref_t</a>, and the interface for working with modrefs uses modref pointers (of type <a class="el" href="group__langcore.html#g2721ca82a2a5915adb3ed5f56c27f174">modref_t</a>*).<p>
From a core-program's perspective, a modref is like any mutable (pointer-sized) location in memory: it can be read-from (using <a class="el" href="group__langcore.html#g162609872673b8b40cba41a4627ee6ee">read</a>) and written-to (using <a class="el" href="group__langcore.html#gc5050d38e1da1e6aaf9ed2494429f5bf">write</a>). In both cases, the read or written value is of type <code>void*</code>. The <a class="el" href="group__langcore.html#g450cffd84b888c265a63ab679946be19">modref</a> function creates fresh modrefs that are initially empty.<p>
Modrefs are typically used to hold inputs and outputs of core programs, as well as their intermediate results. Typically, after the meta-program runs the core program initially, it (1) mutates the core input by writing one or more modrefs with new values (via <a class="el" href="group__langcore.html#gc5050d38e1da1e6aaf9ed2494429f5bf">write</a>), and (2) forces the changes to propagate to core output (via <a class="el" href="group__langmeta.html#g266c38f39f8be698b6a37ede35325083">slime_propagate</a>).<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Before choosing the name <em>CEAL</em>, this project was internally referred to as <em>SLIME</em>. In future revisions, we will rename primitives like <a class="el" href="group__langmeta.html#g266c38f39f8be698b6a37ede35325083">slime_propagate</a> as <code>ceal_propagate</code>.</dd></dl>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>Correct usage of CEAL requires that a modref be written before it is used with <a class="el" href="group__langcore.html#g162609872673b8b40cba41a4627ee6ee">read</a> or <a class="el" href="group__langmeta.html#g4d403ba6f5076f6fd51163e6bcec4fe5">modref_deref</a>. It is important to note that this requirement is not enforced statically or during run-time.</dd></dl>
<h2><a class="anchor" name="examples">
Examples</a></h2>
<ul>
<li><a class="el" href="ex_add.html">Example: Add</a> --- Illustrates the basics with a core program that simply adds two input values.</li></ul>
<p>
<ul>
<li><a class="el" href="ex_arith_tree.html">Example: Arithmetic Trees</a> --- A recursive core program that evaluates arithmetic-expression trees.</li></ul>
<p>
<ul>
<li><a class="el" href="ex_modlist.html">Example: Modifiable Lists</a> --- Core functions that work with ("modifiable") lists (i.e., lists where the meta program may perform insertions and deletions of list elements).</li></ul>
<h2><a class="anchor" name="limitations">
Limitations</a></h2>
<b>TODO</b> </div>
<hr size="1"><address style="text-align: right;"><small>Generated on Thu Mar 5 14:27:55 2009 for CEAL by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
