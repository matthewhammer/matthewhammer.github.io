<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>CEAL Manual and User Guide (DRAFT)</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
<style type="text/css">
BODY, TD{
!  max-width: 5.5in;  
!  margin-left: 1in;
}
</style>
</head>
<!-- Generated by Doxygen 1.5.6 -->
<div class="contents">
<h1>Core-Language Primitives</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g6e686a484993ce30ff9a77728e79c1f7"></a><!-- doxytag: member="langcore::afun" ref="g6e686a484993ce30ff9a77728e79c1f7" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>afun</b>&nbsp;&nbsp;&nbsp;void</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g9c93fb8ade0e549753a6e4bf9e86e3f9"></a><!-- doxytag: member="langcore::wfun" ref="g9c93fb8ade0e549753a6e4bf9e86e3f9" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>wfun</b>&nbsp;&nbsp;&nbsp;void</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g937528b844bc4fa38245f6b9fe1a1441"></a><!-- doxytag: member="langcore::ifun" ref="g937528b844bc4fa38245f6b9fe1a1441" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ifun</b>&nbsp;&nbsp;&nbsp;void</td></tr>

<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g2721ca82a2a5915adb3ed5f56c27f174"></a><!-- doxytag: member="langcore::modref_t" ref="g2721ca82a2a5915adb3ed5f56c27f174" args="" -->
typedef struct modref_s&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__langcore.html#g2721ca82a2a5915adb3ed5f56c27f174">modref_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modifiable references. <br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__langcore.html#g6ef5a472cfe576e78e9841ac67d913c8">scope</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a new scope and makes it active.  <a href="#g6ef5a472cfe576e78e9841ac67d913c8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__langcore.html#g0f2f4b7eb5734fff689ce8c3cbd313da">alloc</a> (uintptr_t size,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate and initialize memory blocks.  <a href="#g0f2f4b7eb5734fff689ce8c3cbd313da"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g450cffd84b888c265a63ab679946be19"></a><!-- doxytag: member="langcore::modref" ref="g450cffd84b888c265a63ab679946be19" args="()" -->
<a class="el" href="group__langcore.html#g2721ca82a2a5915adb3ed5f56c27f174">modref_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__langcore.html#g450cffd84b888c265a63ab679946be19">modref</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a new, empty modifiable reference and returns a pointer to it. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__langcore.html#g162609872673b8b40cba41a4627ee6ee">read</a> (<a class="el" href="group__langcore.html#g2721ca82a2a5915adb3ed5f56c27f174">modref_t</a> *m)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads and returns the current value of a modifiable reference.  <a href="#g162609872673b8b40cba41a4627ee6ee"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gc5050d38e1da1e6aaf9ed2494429f5bf"></a><!-- doxytag: member="langcore::write" ref="gc5050d38e1da1e6aaf9ed2494429f5bf" args="(modref_t *m, void *val)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__langcore.html#gc5050d38e1da1e6aaf9ed2494429f5bf">write</a> (<a class="el" href="group__langcore.html#g2721ca82a2a5915adb3ed5f56c27f174">modref_t</a> *m, void *val)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes the given modifiable reference <code>m</code> with the given value <code>val</code>. <br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
See <a class="el" href="index.html#prims">Language Primitives</a> for a high-level explanation of how these primitives are used.<p>
See <a class="el" href="index.html#limitations">Limitations</a> for an overview of associated caveats. <hr><h2>Function Documentation</h2>
<a class="anchor" name="g0f2f4b7eb5734fff689ce8c3cbd313da"></a><!-- doxytag: member="langcore.h::alloc" ref="g0f2f4b7eb5734fff689ce8c3cbd313da" args="(uintptr_t size,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* alloc           </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Allocate and initialize memory blocks. 
<p>
The variadic arguments of <a class="el" href="group__langcore.html#g0f2f4b7eb5734fff689ce8c3cbd313da">alloc</a> correspond to an initialization function and series of zero or more initialization values. After allocating a block of memory of the requested size (in bytes) this primitive invokes the given initialization function, supplying the address of the allocated block and any additional initialization values.<p>
As an example, consider the following usage to allocate memory for a pair of integers:<p>
<div class="fragment"><pre class="fragment">   <span class="keywordtype">int</span>* pair = <a class="code" href="group__langcore.html#g0f2f4b7eb5734fff689ce8c3cbd313da" title="Allocate and initialize memory blocks.">alloc</a>(2 * <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), pair_initfn, 1, 2);
   printf(<span class="stringliteral">"(%d, %d)"</span>, pair[0], pair[1]);
</pre></div><p>
Where <code>pair_initfn</code> is the following:<p>
<div class="fragment"><pre class="fragment">   <span class="keywordtype">void</span> pair_initfn(<span class="keywordtype">int</span> *pair, <span class="keywordtype">int</span> fst, <span class="keywordtype">int</span> snd) {
     pair[0] = fst;
     pair[1] = snd;
   }
</pre></div><p>
In example uage above, the <a class="el" href="group__langcore.html#g0f2f4b7eb5734fff689ce8c3cbd313da">alloc</a> primitive allocates a block large enough to hold two integers. Say <code>p</code> points at the new block. Next, the primtive effectively executes <code>initfn(p,1,2)</code> to initialize this block. Last, it returns <code>p</code>, whose value is then assigned to <code>pair</code> in the example code.<p>
In core programs we use the <a class="el" href="group__langcore.html#g0f2f4b7eb5734fff689ce8c3cbd313da">alloc</a> primitive instead of a conventional allocation function (e.g., <code>malloc</code>) since uses of the <a class="el" href="group__langcore.html#g0f2f4b7eb5734fff689ce8c3cbd313da">alloc</a> primitive are included in the trace of a core computation. This is significant for several reasons:<p>
<ul>
<li><b>Automatic Garbage Collection</b>: When the core program is re-evaluated by change propagation some of the old trace may be thrown away and replaced with a new computation. When the thrown-away computation contains memory allocations performed by <a class="el" href="group__langcore.html#g0f2f4b7eb5734fff689ce8c3cbd313da">alloc</a>, change propagation automatically reclaims them as garbage.</li></ul>
<p>
<ul>
<li><b>Reuse of Previous Allocations</b>: When the core program is re-evaluated and performs new allocations, the <a class="el" href="group__langcore.html#g0f2f4b7eb5734fff689ce8c3cbd313da">alloc</a> primitive attempts to <em>reuse</em> allocations from the trace when they're available. This is crucial for writing stable programs.</li></ul>
<p>
<ul>
<li><b>Correctness of Change Propagation</b>: Change propagation relies on the assumption that only the contents of modrefs change value as a core program runs, and that the core program treats all other memory as immutable. In practical terms, this means that the core program cannot change the value of (non-modref) memory locations after allocating them. In particular, if a block of memory is <em>reused</em> during the re-evaluation of a core program, the core program <em>should not</em> initialize it a second time. By combining the memory's initialization with allocation, the core program avoids this problem: when a block of memory is freshly allocated, the system runs the associated intialization function; and when an allocation is reused, the associated initialization function is not rerun. </li></ul>

</div>
</div><p>
<a class="anchor" name="g162609872673b8b40cba41a4627ee6ee"></a><!-- doxytag: member="langcore.h::read" ref="g162609872673b8b40cba41a4627ee6ee" args="(modref_t *m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* read           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__langcore.html#g2721ca82a2a5915adb3ed5f56c27f174">modref_t</a> *&nbsp;</td>
          <td class="paramname"> <em>m</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads and returns the current value of a modifiable reference. 
<p>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>Reading an unwritten modref is an error.<p>
Unlike the other core primitives, <a class="el" href="group__langcore.html#g162609872673b8b40cba41a4627ee6ee">read</a> may only be used inside core functions (i.e., those with return type afun) </dd></dl>

</div>
</div><p>
<a class="anchor" name="g6ef5a472cfe576e78e9841ac67d913c8"></a><!-- doxytag: member="langcore.h::scope" ref="g6ef5a472cfe576e78e9841ac67d913c8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void scope           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a new scope and makes it active. 
<p>
It will remain active until the currently-executing function is complete, or until its replaced with another scope. Support for this primitive (currently) has some important caveats. See <a class="el" href="index.html#limitations">Limitations</a> for details. 
</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Thu Mar 5 14:27:55 2009 for CEAL by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
